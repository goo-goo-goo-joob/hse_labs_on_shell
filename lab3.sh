#функция обработки прерывания
break_func()
{
#увеличим счетчик прерываний
#let считает арифметические и условные выражения
let "sign_num = sign_num + 1"		

#если число прерываний равно 5 и мы считали название файла (флаг равен 1)
#test проверяет условие, -а это логическое и
if test $sign_num -eq 5 -a $flag -eq 1
#выводим результат выполнения команды в `` (количество символов указанного файла)
then echo Прерывание №5! Количество символов файла: `wc -c < $name`
fi

#если число прерываний равно 5 и НО мы не считали название файла
if test $sign_num -eq 5 -a $flag -eq 0 
then echo "Прерывание №5. Вы не ввели файл."
fi

#если число прерываний меньше 5 и мы не ввели файл
if test $sign_num -lt 5 -a $flag -eq 0 
then echo Прерывание №$sign_num! Введите файл: 
fi

#если число прерываний меньше 5 и мы ввели файл (не нужно просить еще раз ввести файл)
if test $sign_num -lt 5 -a $flag -eq 1 
then echo Прерывание №$sign_num! 
fi

#если число прерываний больше или равно 6, то мы завершаем программу
if test $sign_num -ge 6 
then echo "Конец программы"
exit 1
fi
}

#устанавливаем функцию-обработчик прерывания на сигнал ctr+c
trap "break_func" SIGINT	
#инициализируем счетчик числа прерываний
sign_num=0
#инициализируем флаг того, что файл считан
flag=0	
echo "Введите файл:"
read name	
#если файл с таким именем не существует, то просим ввести, пока не получим название существующего файла
while ! test -f "$name"
do
echo "Файл не найден. Введите еще раз."
read name
done
#файл считан, изменяем флаг
flag=1		

#du выводит количество блоков (только для директорий), -а ключ позволяет вывести для всех файлов
#tee перенаправляет ввод нашей программы на 2 команды: tail и grep
#tail -1 выводит последнюю строчку (там содержится информация об общем количестве блоков)
#grep ищет запись с названием нашего файла (./ нужна для того, чтобы показать, что файл находится в этой директории. grep все выводит, начиная с ./)
#cut вырезает первое поле (нам нужны только числа), tail выводит посление 2 нужные нам записи (tee выводит всю информацию (по блокам от du) сразу на экран, а нам это не нужно)
#есть ньюанс из-за особенностей tee, что писать команды надо в обратном порядке, чтобы вывод соответствовал ожиданиям

echo Количество блоков файла и общее количество блоков: `du -a | tee >(tail -1) >(grep ./$name) | cut -f 1 | tail -2`

#бесконечный цикл, пока не поступит 6-е прерывание
while :
do
sleep 1
done
